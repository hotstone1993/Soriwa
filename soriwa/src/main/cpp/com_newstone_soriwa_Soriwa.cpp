/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <string>
/* Header for class com_newstone_soriwa_Soriwa */
#include "include/com_newstone_soriwa_Soriwa.h"
#include "include/Soriwa.h"
#include "common_header.h"
#include "soriwa_version.h"

const char* const INSTANCE = "nativeInstance";

#ifdef __cplusplus
extern "C" {
#endif

jobject objInstance;

#define GET_MEMBER(env, obj, member_cls, type1, type2, type3, member_name) \
    jfieldID member_name##_id1 = env->GetFieldID(member_cls, #member_name, type3);  \
    type1 member_name = env->Get##type2##Field(obj, member_name##_id1);

#define GET_CONFIGURATION(env, configObj, configCls) \
    GET_MEMBER(env, configObj, configCls, jint, Int, "I", playMode) \
    GET_MEMBER(env, configObj, configCls, jint, Int, "I", sharingMode) \
    GET_MEMBER(env, configObj, configCls, jint, Int, "I", frameSize) \
    Configuration temp; \
    temp.sharingMode = playMode; \
    temp.playMode = sharingMode; \
    temp.frameSize = frameSize;

Soriwa* getInstance(JNIEnv* env, const jobject& obj) {
    jclass cls = env->GetObjectClass(obj);
    jfieldID id = env->GetFieldID(cls, INSTANCE, "J");
    jlong instancePointer = env->GetLongField(obj, id);
    return reinterpret_cast<Soriwa*>(instancePointer);
}

// https://stackoverflow.com/questions/30026030/what-is-the-best-way-to-save-jnienv/30026231#30026231
JavaVM* g_vm = nullptr;

void DeferThreadDetach(JNIEnv *env) {
    static pthread_key_t thread_key;

    // Set up a Thread Specific Data key, and a callback that
    // will be executed when a thread is destroyed.
    // This is only done once, across all threads, and the value
    // associated with the key for any given thread will initially
    // be NULL.
    static auto run_once = [] {
        const auto err = pthread_key_create(&thread_key, [] (void *ts_env) {
            if (ts_env) {
                g_vm->DetachCurrentThread();
            }
        });
        if (err) {
            // Failed to create TSD key. Throw an exception if you want to.
        }
        return 0;
    }();

    // For the callback to actually be executed when a thread exits
    // we need to associate a non-NULL value with the key on that thread.
    // We can use the JNIEnv* as that value.
    const auto ts_env = pthread_getspecific(thread_key);
    if (!ts_env) {
        if (pthread_setspecific(thread_key, env)) {
            // Failed to set thread-specific value for key. Throw an exception if you want to.
        }
    }
}

JNIEnv* GetJniEnv() {
    JNIEnv *env = nullptr;
    // We still call GetEnv first to detect if the thread already
    // is attached. This is done to avoid setting up a DetachCurrentThread
    // call on a Java thread.

    // g_vm is a global.
    auto get_env_result = g_vm->GetEnv((void**)&env, JNI_VERSION_1_6);
    if (get_env_result == JNI_EDETACHED) {
        if (g_vm->AttachCurrentThread(&env, NULL) == JNI_OK) {
            DeferThreadDetach(env);
        } else {
            // Failed to attach thread. Throw an exception if you want to.
        }
    } else if (get_env_result == JNI_EVERSION) {
        // Unsupported JNI version. Throw an exception if you want to.
    }
    return env;
}
////////////////////////////////////////////////////////////////////////////////////////////////////

void renderer(float* input, float* output, int samplePerBlock) {
    // std::lock_guard<std::mutex> lt(lock_);
    static jmethodID cb = nullptr;
    JNIEnv* envInstance = GetJniEnv();

    if (nullptr == cb){
        jclass cls = envInstance->GetObjectClass(objInstance);
        cb = envInstance->GetMethodID(cls, "render", "([F[FI)V");
    }
    jfloatArray jInput = envInstance->NewFloatArray(samplePerBlock);
    jfloatArray jOutput = envInstance->NewFloatArray(samplePerBlock);

    envInstance->SetFloatArrayRegion(jInput, 0, samplePerBlock, input);
    envInstance->CallVoidMethod(objInstance, cb, jInput, jOutput, samplePerBlock);
    float* tempInput = envInstance->GetFloatArrayElements(jInput, NULL);
    float* tempOutput = envInstance->GetFloatArrayElements(jOutput, NULL);
    memcpy(output, tempOutput, sizeof(float) * samplePerBlock);
    envInstance->ReleaseFloatArrayElements(jInput, tempInput, JNI_ABORT);
    envInstance->ReleaseFloatArrayElements(jOutput, tempOutput, JNI_ABORT);
}

JNIEXPORT void JNICALL Java_com_newstone_soriwa_Soriwa_init(JNIEnv *env, jobject obj) {
    env->GetJavaVM(&g_vm);
    objInstance = env->NewGlobalRef(obj);
    Soriwa* newInstance = new Soriwa();
    newInstance->init();

    jclass cls = env->GetObjectClass(obj);
    jfieldID id = env->GetFieldID(cls, INSTANCE, "J");
    env->SetLongField(obj, id, reinterpret_cast<jlong>(newInstance));
}

JNIEXPORT void JNICALL Java_com_newstone_soriwa_Soriwa_deinit(JNIEnv *env, jobject obj) {
    env->DeleteGlobalRef(objInstance);
    Soriwa* instance = getInstance(env, obj);
    instance->deinit();
    delete instance;

    jclass cls = env->GetObjectClass(obj);
    jfieldID id = env->GetFieldID(cls, INSTANCE, "J");
    env->SetLongField(obj, id, 0);
}

JNIEXPORT jint JNICALL Java_com_newstone_soriwa_Soriwa_addAudio(JNIEnv *env, jobject obj, jobject config, jstring filePath) {
    Soriwa* instance = getInstance(env, obj);
    jclass cls = env->GetObjectClass(config);
    std::string path = env->GetStringUTFChars(filePath, NULL);
    GET_CONFIGURATION(env, config, cls)
    int id = instance->addAudio(temp, path);
    instance->setRenderer(id, renderer);

    return id;
}

JNIEXPORT jint JNICALL Java_com_newstone_soriwa_Soriwa_deleteAudioById(JNIEnv *env, jobject obj, jint id) {
    int result = 0;
    Soriwa* instance = getInstance(env, obj);
    result = instance->deleteAudioById(id);
    return result;
}

JNIEXPORT jint JNICALL Java_com_newstone_soriwa_Soriwa_play(JNIEnv *env, jobject obj, jint id) {
    int result = 0;
    Soriwa* instance = getInstance(env, obj);
    result = instance->play(id);
    return result;
}

JNIEXPORT jint JNICALL Java_com_newstone_soriwa_Soriwa_stop(JNIEnv *env, jobject obj, jint id) {
    int result = 0;
    Soriwa* instance = getInstance(env, obj);
    result = instance->stop(id);
    return result;
}

JNIEXPORT jstring JNICALL Java_com_newstone_soriwa_Soriwa_getVersion(JNIEnv *env, jobject obj) {
    int result = 0;
    std::string version = Version::getVersion();
    jstring jstrBuf = env->NewStringUTF(version.c_str());

    return jstrBuf;
}
#ifdef __cplusplus
}
#endif